




## 【Segumi OS 番组计划(Segumi Obsidian System)】
```dataviewjs
// --- 通用函数：创建按钮 ---
function createButton(container, text, onClick) {
  const button = container.createEl('button', { text: text });
  button.onclick = onClick;
  return button;
}

// --- 通用函数：创建笔记容器 ---
function createNoteContainer(container) {
  return container.createEl('div', { cls: 'note-container' });
}

// --- 通用函数：添加 CSS 样式 ---
function addStyle(styleContent) {
  const style = document.createElement('style');
  style.textContent = styleContent;
  document.head.append(style);
}

// --- 函数：表格 1 ---
async function 表格1(noteContainer) {
  dv.paragraph(""); // 清空旧的内容
  // 在这里添加表格 1 的代码
/**
 * 从链接中提取 Subject ID。
 * @param {string} link - 要提取 ID 的链接。
 * @returns {string|null} 提取的 Subject ID，如果未找到则返回 null。
 */
function extractSubjectID(link) {
    if (!link) return null;
    const match = link.match(/subject\/(\d+)/);
    return match ? match[1] : null;
}

/**
 * 获取所有符合条件的页面数据。
 */
const pages = dv.pages('"藏书阁/阅读"')
    .where(p => p.开始时间 >= 5 && p.结束时间 < 5)
    .sort(p => p.开始时间, 'desc');

/**
 * 过滤出包含开始时间和种类的完整页面数据。
 */
const completePages = pages;

/**
 * 初始化表格数据数组，不包含表头。
 */
let tableData = [];

/**
 * 用于存储已处理的主类别及其对应的页面数据。
 */
const categoryMap = {};

/**
 * 遍历所有页面，处理种类及其子标签。
 */
completePages.forEach(p => {
    let category = p["种类"];
    if (category) {
        // 如果种类包含“/”，则认为是子标签，提取主标签
        if (category.includes("/")) {
            const parts = category.split("/");
            category = parts[0].trim(); // 获取主标签
        }
        // 如果主标签不存在，则创建新的条目
        if (!categoryMap[category]) {
            categoryMap[category] = [];
        }
        categoryMap[category].push(p); // 将页面数据添加到对应主标签下
    }
});

/**
 * 根据处理后的分类数据生成表格数据。
 */
for (const category in categoryMap) {
    const categoryPages = categoryMap[category];

    tableData.push([`**${category}**`, "", "", "", ""]);

    categoryPages.forEach(p => {
        const subjectID = extractSubjectID(p.链接);
        const bgmLink = subjectID ? `[bgm${subjectID}](https://bgm.tv/subject/${subjectID})` : "";

        let launchButton = '';
        const encodedPath = encodeURI(p.file.path);

        const originalCategory = p["种类"]; // 获取原始种类信息

        if (originalCategory === "视觉小说" || originalCategory === "游戏" || originalCategory === "RPG" || originalCategory === "漫画") {
            const launchLink = subjectID ? `localexplorer:${encodeURI(`F:\\Games\\galgame\\bgm${subjectID}`)}` : '';
            if (launchLink) launchButton = `[启动](${launchLink})`;
        } else if (originalCategory === "网课") {
            launchButton = `[启动](${p["链接"]})`;
        } else if (originalCategory === "动画") {
            const encodedAHKPath = encodeURI(`file:///D:/Tools/Autohotkey/打开动画放映器.ahk`);
            launchButton = `[启动](${encodedAHKPath})`;
        }

        const titleLink = `[${p["标题"]}](${encodedPath})`;

        tableData.push([
            launchButton,
            titleLink,
            `[${originalCategory}](${p["链接"]})`,
            p["开始时间"],
            bgmLink
        ]);
    });
}

// 调用 dv.table 函数时手动添加表头
dv.table(
    ["启动", "标题", "种类", "开始时间", "Bangumi ID"],
    tableData
);
}

// --- 函数：表格 2 ---
async function 表格2(noteContainer) {
  dv.paragraph(""); // 清空旧的内容
  // 在这里添加表格 2 的代码
  /**
 * 从链接中提取 Subject ID。
 * @param {string} link - 要提取 ID 的链接。
 * @returns {string|null} 提取的 Subject ID，如果未找到则返回 null。
 */
function extractSubjectID(link) {
    if (!link) return null;
    const match = link.match(/subject\/(\d+)/);
    return match ? match[1] : null;
}

/**
 * 获取所有符合条件的页面数据。
 */
const pages = dv.pages('"藏书阁/阅读"')
    .where(p => p.开始时间 < 5 && p.结束时间 < 5)
    .sort(p => p.开始时间, 'desc');

/**
 * 过滤出包含开始时间和种类的完整页面数据。
 */
const completePages = pages;

/**
 * 初始化表格数据数组，不包含表头。
 */
let tableData = [];

/**
 * 用于存储已处理的主类别及其对应的页面数据。
 */
const categoryMap = {};

/**
 * 遍历所有页面，处理种类及其子标签。
 */
completePages.forEach(p => {
    let category = p["种类"];
    if (category) {
        // 如果种类包含“/”，则认为是子标签，提取主标签
        if (category.includes("/")) {
            const parts = category.split("/");
            category = parts[0].trim(); // 获取主标签
        }
        // 如果主标签不存在，则创建新的条目
        if (!categoryMap[category]) {
            categoryMap[category] = [];
        }
        categoryMap[category].push(p); // 将页面数据添加到对应主标签下
    }
});

/**
 * 根据处理后的分类数据生成表格数据。
 */
for (const category in categoryMap) {
    const categoryPages = categoryMap[category];

    tableData.push([`**${category}**`, "", "", "", ""]);

    categoryPages.forEach(p => {
        const subjectID = extractSubjectID(p.链接);
        const bgmLink = subjectID ? `[bgm${subjectID}](https://bgm.tv/subject/${subjectID})` : "";

        let launchButton = '';
        const encodedPath = encodeURI(p.file.path);

        const originalCategory = p["种类"]; // 获取原始种类信息

        if (originalCategory === "视觉小说" || originalCategory === "游戏" || originalCategory === "RPG" || originalCategory === "漫画") {
            const launchLink = subjectID ? `localexplorer:${encodeURI(`F:\\Games\\galgame\\bgm${subjectID}`)}` : '';
            if (launchLink) launchButton = `[启动](${launchLink})`;
        } else if (originalCategory === "网课") {
            launchButton = `[启动](${p["链接"]})`;
        } else if (originalCategory === "动画") {
            const encodedAHKPath = encodeURI(`file:///D:/Tools/Autohotkey/打开动画放映器.ahk`);
            launchButton = `[启动](${encodedAHKPath})`;
        }

        const titleLink = `[${p["标题"]}](${encodedPath})`;

        tableData.push([
            launchButton,
            titleLink,
            `[${originalCategory}](${p["链接"]})`,
            p["开始时间"],
            bgmLink
        ]);
    });
}

// 调用 dv.table 函数时手动添加表头
dv.table(
    ["启动", "标题", "种类", "开始时间", "Bangumi ID"],
    tableData
);
}

// --- 函数：表格 3 ---
async function 表格3(noteContainer) {
  dv.paragraph(""); // 清空旧的内容
  // 在这里添加表格 3 的代码
/**
 * 从链接中提取 Subject ID。
 * @param {string} link - 要提取 ID 的链接。
 * @returns {string|null} 提取的 Subject ID，如果未找到则返回 null。
 */
function extractSubjectID(link) {
    if (!link) return null;
    const match = link.match(/subject\/(\d+)/);
    return match ? match[1] : null;
}

/**
 * 获取所有符合条件的页面数据。
 */
const pages = dv.pages('"藏书阁/阅读"')
    .where(p => p.开始时间 >= 5 && p.结束时间 >= 5)
    .sort(p => p.开始时间, 'desc');

/**
 * 过滤出包含开始时间和种类的完整页面数据。
 */
const completePages = pages;

/**
 * 初始化表格数据数组，不包含表头。
 */
let tableData = [];

/**
 * 用于存储已处理的主类别及其对应的页面数据。
 */
const categoryMap = {};

/**
 * 遍历所有页面，处理种类及其子标签。
 */
completePages.forEach(p => {
    let category = p["种类"];
    if (category) {
        // 如果种类包含“/”，则认为是子标签，提取主标签
        if (category.includes("/")) {
            const parts = category.split("/");
            category = parts[0].trim(); // 获取主标签
        }
        // 如果主标签不存在，则创建新的条目
        if (!categoryMap[category]) {
            categoryMap[category] = [];
        }
        categoryMap[category].push(p); // 将页面数据添加到对应主标签下
    }
});

/**
 * 根据处理后的分类数据生成表格数据。
 */
for (const category in categoryMap) {
    const categoryPages = categoryMap[category];

    tableData.push([`**${category}**`, "", "", "", ""]);

    categoryPages.forEach(p => {
        const subjectID = extractSubjectID(p.链接);
        const bgmLink = subjectID ? `[bgm${subjectID}](https://bgm.tv/subject/${subjectID})` : "";

        let launchButton = '';
        const encodedPath = encodeURI(p.file.path);

        const originalCategory = p["种类"]; // 获取原始种类信息

        if (originalCategory === "视觉小说" || originalCategory === "游戏" || originalCategory === "RPG" || originalCategory === "漫画") {
            const launchLink = subjectID ? `localexplorer:${encodeURI(`F:\\Games\\galgame\\bgm${subjectID}`)}` : '';
            if (launchLink) launchButton = `[启动](${launchLink})`;
        } else if (originalCategory === "网课") {
            launchButton = `[启动](${p["链接"]})`;
        } else if (originalCategory === "动画") {
            const encodedAHKPath = encodeURI(`file:///D:/Tools/Autohotkey/打开动画放映器.ahk`);
            launchButton = `[启动](${encodedAHKPath})`;
        }

        const titleLink = `[${p["标题"]}](${encodedPath})`;

        tableData.push([
            launchButton,
            titleLink,
            `[${originalCategory}](${p["链接"]})`,
            p["开始时间"],
            bgmLink
        ]);
    });
}

// 调用 dv.table 函数时手动添加表头
dv.table(
    ["启动", "标题", "种类", "开始时间", "Bangumi ID"],
    tableData
);
}

// --- 函数：表格 4 ---
async function 表格4(noteContainer) {
  dv.paragraph(""); // 清空旧的内容
  // 在这里添加表格 4 的代码
  // Function to extract the Bangumi subject ID from the URL
function extractSubjectID(link) {
  if (!link) return null; // Check if the link is defined
  const match = link.match(/subject\/(\d+)/);
  return match ? match[1] : null;
}

// Get all pages that match the query and are not done
const pages = dv.pages('"藏书阁/阅读"')
  .where(p => !p.done);

// Prepare the table data for software file names and corresponding titles
let tableData = [];

// Filter pages that have a BGM link and are not "动画"
const softwarePages = pages.where(p => {
  const subjectID = extractSubjectID(p.链接);
  return subjectID && p["种类"] !== "动画"&& p["种类"] !== "游戏";
});

// Iterate over the filtered pages and extract the file names (bgm<subjectID>) and titles
softwarePages.forEach(p => {
  const subjectID = extractSubjectID(p.链接);
  if (subjectID) {
    const fileName = `bgm${subjectID}`;
    const title = p["标题"]; // Get the corresponding title
    tableData.push([fileName, title]);
  }
});

// Create a table with the file names and corresponding titles
dv.table(
  ["软件文件名称", "对应名称"], // Table headers
  tableData
);
}

// --- 主要逻辑 ---
const container = dv.el('div');

// 创建按钮容器
const buttonContainer = container.createEl('div');

// 创建笔记容器
const noteContainer = createNoteContainer(container);

// 创建按钮并绑定事件
createButton(buttonContainer, '进行中', () => 表格1(noteContainer));
createButton(buttonContainer, '愿望单', () => 表格2(noteContainer));
createButton(buttonContainer, '已完成', () => 表格3(noteContainer));
createButton(buttonContainer, '搁置', () => 表格4(noteContainer));

// 初始化特定表格
//表格3(noteContainer);

// 添加 CSS 样式
addStyle(`
  button {
    padding: 10px 20px;
    margin-right: 10px;
    cursor: pointer;
  }

  .note-container {
    margin-top: 10px; /* 添加按钮和内容之间的间距 */
  }
`);
```
```dataviewjs
// 函数：从 URL 中提取 Bangumi 条目 ID
function extractSubjectID(link) {
    if (!link) return null;
    const match = link.match(/subject\/(\d+)/);
    return match ? match[1] : null;
}

// 函数：根据页面种类创建启动按钮，使用动态匹配
function createLaunchButton(page) {
    let launchButton = '';
    const subjectID = extractSubjectID(page.链接);
    const encodedPath = encodeURI(page.file.path);
    const category = page["种类"];

    if (category) {
        // 动态匹配规则，可以根据需要添加更多规则
        if (category === "视觉小说" || category === "游戏" || category === "RPG" || category === "漫画") {
            const launchLink = subjectID ? `localexplorer:${encodeURI(`F:\\Games\\galgame\\bgm${subjectID}`)}` : '';
            if (launchLink) launchButton = `[启动](${launchLink})`;
        } else if (category === "网课") {
            launchButton = `[启动](${page["链接"]})`;
        } else if (category === "动画") {
            const encodedAHKPath = encodeURI(`file:///D:/Tools/Autohotkey/打开动画放映器.ahk`);
            launchButton = `[启动](${encodedAHKPath})`;
        }
         // 添加更多自定义种类的启动方式...
    }
    return launchButton;
}

// 函数：渲染“最近添加”部分
function renderRecentItems(pages) {
    let tableData = [];
    tableData.push(["**最近添加**", "", "", "", ""]);

    const recentItems = pages
        .limit(8); // 直接限制数量，不进行种类过滤

    recentItems.forEach(p => {
        const subjectID = extractSubjectID(p.链接);
        const bgmLink = subjectID ? `[bgm${subjectID}](https://bgm.tv/subject/${subjectID})` : "";
        const launchButton = createLaunchButton(p);
        const titleLink = `[${p["标题"]}](${encodeURI(p.file.path)})`;
        const category = p["种类"] || "其他"; // 如果没有种类，显示为“其他”

        tableData.push([
            launchButton,
            titleLink,
            category ? `[${category}](${p["链接"]})` : "",
            p["开始时间"],
            bgmLink
        ]);
    });

    tableData.push(["---", "---", "---", "---", "---"]);
    return tableData;
}

// 主函数
function main() {
    // 获取所有匹配查询且状态为“进行中”的页面，并按开始时间降序排序，处理包含空格的文件路径
    const pages = dv.pages('"藏书阁/阅读"')
        .where(p => p.开始时间 >= 5 && p.结束时间 < 5)
        .sort(p => p.开始时间, 'desc');

    // 直接获取完整的页面，不再分离信息缺失的页面
    const completePages = pages;

    // 获取“最近添加”部分的表格数据
    const recentTableData = renderRecentItems(completePages);

    // 渲染表格
    dv.table(
        ["启动", "标题", "种类", "开始时间", "Bangumi ID"],
        recentTableData
    );
}

// 执行主函数
main();
```
# 【其他小组件】
```dataviewjs
// --- 通用函数：创建按钮 ---
function createButton(container, text, onClick) {
  const button = container.createEl('button', { text: text });
  button.onclick = onClick;
  return button;
}

// --- 通用函数：创建笔记容器 ---
function createNoteContainer(container) {
  return container.createEl('div', { cls: 'note-container' });
}

// --- 通用函数：添加 CSS 样式 ---
function addStyle(styleContent) {
  const style = document.createElement('style');
  style.textContent = styleContent;
  document.head.append(style);
}

// --- 函数：表格 1 ---
async function 表格1(noteContainer) {
  dv.paragraph(""); // 清空旧的内容
  // 在这里添加表格 1 的代码
  let pages = dv.pages('"藏书阁/日记"')
    .where(p => p.file.cday <= dv.date("today"))
    .sort(p => p.file.name, 'desc');

  if (pages.length === 0) {
    dv.paragraph("没有找到符合条件的日记。");
    return;
  }

  dv.table(
    ["日记链接", "标题", "评分", "事件", "待办", "标签"], 
    pages.map(p => [
      p.file.link,
      p.标题,
      p.评分,
      p.事件,
      p.待办,
      p.tags
    ])
  );
}

// --- 函数：表格 2 ---
async function 表格2(noteContainer) {
  dv.paragraph(""); // 清空旧的内容
  // 在这里添加表格 2 的代码
  dv.paragraph(`![[更新随想.canvas]]`); 
}

// --- 函数：表格 3 ---
async function 表格3(noteContainer) {
  dv.paragraph(""); // 清空旧的内容
  // 在这里添加表格 3 的代码

}

// --- 函数：表格 4 ---
async function 表格4(noteContainer) {
  dv.paragraph(""); // 清空旧的内容
  // 在这里添加表格 4 的代码
  dv.paragraph(`![[统计备份.canvas]]`); // 显示随笔
}

// --- 主要逻辑 ---
const container = dv.el('div');

// 创建按钮容器
const buttonContainer = container.createEl('div');

// 创建笔记容器
const noteContainer = createNoteContainer(container);

// 创建按钮并绑定事件
createButton(buttonContainer, '日记', () => 表格1(noteContainer));
createButton(buttonContainer, '更新随想', () => 表格2(noteContainer));
createButton(buttonContainer, '年度总结', () => 表格3(noteContainer));
createButton(buttonContainer, '统计备份', () => 表格4(noteContainer));

// 初始化显示表格 3 (显示图片)
///表格3(noteContainer);

// 添加 CSS 样式
addStyle(`
  button {
    padding: 10px 20px;
    margin-right: 10px;
    cursor: pointer;
  }

  .note-container {
    margin-top: 10px; /* 添加按钮和内容之间的间距 */
  }
`);
```
```dataviewjs
let today = moment().format("YYYY-MM-DD");
let thisMonth = moment().month(); 
let thisYear = moment().year();

let pages = dv.pages('"藏书阁/日记"').where(p => p.file.cday);

let tasksWithDates = [];
for (let page of pages) {
  let date = page.file.name.slice(0, 10);
  let daysDiff = moment(date).diff(moment(today), 'days');

  if (daysDiff >= 0) {
    let tasks = page.待办;
    if (tasks) {
      if (Array.isArray(tasks)) {
        for (let task of tasks) {
          tasksWithDates.push({ task: task, date: date, daysDiff: daysDiff });
        }
      } else {
        tasksWithDates.push({ task: tasks, date: date, daysDiff: daysDiff });
      }
    }
  }
}

tasksWithDates.sort((a, b) => a.daysDiff - b.daysDiff);

// 获取节假日信息
let holidays = {};
async function fetchHolidays(year) {
  try {
    let response = await fetch(`http://timor.tech/api/holiday/year/${year}/`);
    let data = await response.json();
    if (data.code === 0) {
      holidays = data.holiday;
    } else {
      console.error(`获取 ${year} 年节假日信息失败: ${data.msg}`);
    }
  } catch (error) {
    console.error(`获取 ${year} 年节假日信息失败: ${error}`);
  }
}

await fetchHolidays(thisYear); // 获取今年的节假日信息


function generateCalendar(year, month) {
  let calendarMonth = moment(new Date(year, month, 1)); 
  let daysInMonth = calendarMonth.daysInMonth();
  let firstDayOfMonth = calendarMonth.startOf('month').day(); 

  let calendar = `<td style="border: 1px solid #ccc; padding: 10px;">`; 
  calendar += `<table style='width:100%; border-collapse: collapse; transform: scale(1.0); transform-origin: top left;'>`; // 将表格缩小到原来的 90%
  calendar += `<tr style='font-weight: bold; text-align: center;'><td colspan="7">${calendarMonth.format("MM 月")}</td></tr>`; 
  calendar += "<tr style='font-weight: bold; background-color: #f2f2f2;'><td>    日</td><td> 一</td><td> 二</td><td> 三</td><td> 四</td><td> 五</td><td> 六</td></tr>";

  let currentDay = 1;
  for (let week = 0; week < 6; week++) {
    calendar += "<tr>";
    for (let day = 0; day < 7; day++) {
      if (week === 0 && day < firstDayOfMonth) {
        calendar += "<td style='background-color: #f2f2f2; border: 1px solid #e0e0e0;'></td>"; 
      } else if (currentDay > daysInMonth) {
        calendar += "<td style='background-color: #f2f2f2; border: 1px solid #e0e0e0;'></td>";
      } else {
        let taskContent = "";
        let cellDate = calendarMonth.startOf('month').add(currentDay - 1, 'days').format("YYYY-MM-DD");

        tasksWithDates.forEach(taskData => {
          if (taskData.date === cellDate) {
            let color = "red"; // 默认颜色
            let fontSize = "10px";
            let fontWeight = "normal";
            if (taskData.daysDiff === 0) {
              color = "red";
              fontSize = "10px";
              fontWeight = "bold";
              taskContent += `<span style="color:${color}; font-size: ${fontSize}; font-weight: ${fontWeight};">⏰ ${taskData.task}</span><br>`;
            } else {
              taskContent += `<span style="color:${color}; font-size: ${fontSize};"> ${taskData.task}</span><br>`;
            }
          }
        });

        // 检查日期是否为节假日
        let isHoliday = false;
        let holidayName = "";
        if (holidays[cellDate.slice(5)]) {
          isHoliday = holidays[cellDate.slice(5)].holiday;
          holidayName = holidays[cellDate.slice(5)].name;
        }

        // 高亮今天的日期框和节假日
        let cellStyle = "";
        if (cellDate === today) {
          cellStyle = "background-color: #d3d3d3; border: 2px solid #000;";
        } else if (isHoliday) {
          cellStyle = "background-color: #fcfcfc; border: 0px solid #000;";
        } else {
          cellStyle = "border: 1px solid #ddd; padding: 5px; vertical-align: top;";
        }
        calendar += `<td style='${cellStyle}'>${currentDay}<br>${taskContent}${isHoliday ? `<span style="color: blue;">${holidayName}</span>` : ''}</td>`;
        currentDay++;
      }
    }
    calendar += "</tr>";
  }
  calendar += `</table></td>`; 
  return calendar;
}

// 渲染本月及之后 12 个月的日历
let calendarHTML = `<table style='width:100%; border-collapse: collapse;'><tr><td style="background-color: #ddd; font-weight: bold; text-align: center; vertical-align: middle; width: 5%;">${thisYear} 年</td>`; 
let currentYear = thisYear;
for (let i = 0; i < 12; i++) {
  let year = thisYear;
  let month = thisMonth + i;
  if (month >= 12) {
    year += 1;
    month -= 12;
  }

  // 添加年份标题
  if (year !== currentYear) {
    currentYear = year;
    // 如果是新的一年，需要获取新一年的节假日信息
    await fetchHolidays(year);
    calendarHTML += `<td style="background-color: #ddd; font-weight: bold; text-align: center; vertical-align: middle; width: 5%;">${currentYear} 年</td>`; 
  }
  calendarHTML += generateCalendar(year, month);
}
calendarHTML += `</tr></table>`;

dv.paragraph(`<div style="width: 100%; height: 100%;">${calendarHTML}</div>`);
```

```contributionGraph
title: Contributions
graphType: default
dateRangeValue: 365
dateRangeType: LATEST_DAYS
startOfWeek: 0
showCellRuleIndicators: true
titleStyle:
  textAlign: left
  fontSize: 15px
  fontWeight: normal
dataSource:
  type: PAGE
  value: '"藏书阁/阅读"'
  dateField:
    type: FILE_CTIME
  filters: []
  countField:
    type: DEFAULT
fillTheScreen: false
enableMainContainerShadow: false
cellStyle:
  minWidth: 29px
  minHeight: 13px
cellStyleRules: []

```

```dataviewjs
  let now = new Date();

  let year = now.getFullYear();
  let month = now.getMonth() + 1;
  let date = now.getDate();
  let day = now.getDay();
  let hour = now.getHours();
  let minute = now.getMinutes();

  let dayOfWeek = ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"];

  let timePeriod = "";
  let formattedHour = hour;
  let amPm = "AM";

  if (hour >= 12) {
    amPm = "PM";
    if (hour > 12) {
      formattedHour -= 12;
    }
  }

  if (hour == 0) {
    formattedHour = 12;
  }

  if (hour >= 23 || hour < 2) {
    timePeriod = "深夜";
  } else if (hour >= 2 && hour < 5) {
    timePeriod = "凌晨";
  } else if (hour >= 5 && hour < 6) {
    timePeriod = "清晨";                 
  } else if (hour >= 6 && hour < 9) {
    timePeriod = "早晨";
  } else if (hour >= 9 && hour < 12) {
    timePeriod = "上午";
  } else if (hour >= 12 && hour < 13) {
    timePeriod = "中午";
  } else if (hour >= 13 && hour < 17) {
    timePeriod = "下午";
  } else if (hour >= 17 && hour < 19) {
    timePeriod = "傍晚";
  } else {
    timePeriod = "晚上";
  }

  // 获取准确的emoji时钟
  let clockEmoji = "";
  let hourForEmoji = (hour % 12); // 获取 0-11 的小时数，用于计算 emoji
  if (minute >= 45) {
    hourForEmoji = (hourForEmoji + 1) % 12; // 指向下一个小时
  }
  if (hourForEmoji === 0) {
    hourForEmoji = 12; // 将 0 调整为 12，因为 Unicode 码点中 12 点对应的是 0
  }
  clockEmoji = String.fromCodePoint(0x1F550 + hourForEmoji - 1); // 使用 Unicode 码点计算 emoji


let today = moment().format("YYYY-MM-DD");
let pages = dv.pages('"藏书阁/日记"').where(p => p.file.cday);

let tasksWithDates = [];
for (let page of pages) {
  let date = page.file.name.slice(0, 10);
  let daysDiff = moment(date).diff(moment(today), 'days');

  // 只显示今天以后的待办事项
  if (daysDiff >= 0) {
    let tasks = page.待办;
    if (tasks) {
      if (Array.isArray(tasks)) {
        for (let task of tasks) {
          tasksWithDates.push({ task: task, date: date, daysDiff: daysDiff });
        }
      } else {
        tasksWithDates.push({ task: tasks, date: date, daysDiff: daysDiff });
      }
    }
  }
}

// 按日期从近到远排序
tasksWithDates.sort((a, b) => a.daysDiff - b.daysDiff);

// 获取节假日信息
let holidayData = await fetch("http://timor.tech/api/holiday/year/" + year + "/").then(res => res.json());
let holidays = holidayData.holiday;

let result = "";
for (let taskData of tasksWithDates) {
  let color = "";
  let fontSize = "25px";
  let fontWeight = "normal";
  if (taskData.daysDiff >= 30) {
    color = "black";
  } else if (taskData.daysDiff >= 7) {
    color = "blue";
  } else if (taskData.daysDiff >= 3) {
    color = "purple";
  } else {
    color = "red";
  }

  // 如果是今天，则用更大的红色字体加粗显示
  if (taskData.daysDiff === 0) {
    color = "red";
    fontSize = "35px";
    fontWeight = "bold";
    result += `<span style="color:${color}; font-family: 楷体; font-size: ${fontSize}; font-weight: ${fontWeight};text-decoration: underline;">⏰ 今天 ${taskData.task}（${taskData.date}） </span><br>`;
  } else if (taskData.daysDiff === 1) { 
    color = "red";
    fontSize = "35px";
    fontWeight = "bold";
    result += `<span style="color:${color}; font-family: 楷体; font-size: ${fontSize}; font-weight: ${fontWeight};text-decoration: underline;">🚨 明天 ${taskData.task}（${taskData.date}） </span><br>`;
  } else if (taskData.daysDiff === 2) { 
    color = "red";
    fontSize = "35px";
    result += `<span style="color:${color}; font-family: 楷体; font-size: ${fontSize};">    后天 ${taskData.task}（${taskData.date}） </span><br>`;
  } else if (taskData.daysDiff <= 3) { 
    color = "red";
    fontSize = "30px";
    result += `<span style="color:${color}; font-family: 楷体; font-size: ${fontSize};">     ${taskData.daysDiff}天后 ${taskData.task}（${taskData.date}） </span><br>`;
  } else {
    result += `<span style="color:${color}; font-family: 楷体; font-size: ${fontSize};">      ${taskData.daysDiff}天后 ${taskData.task}（${taskData.date}） </span><br>`;
  }
}

// 存储已经显示的节假日，避免重复显示
let displayedHolidays = [];

// 添加节假日信息，只显示后面的三个节假日
let holidayCount = 0; // 计数器，用于限制显示的节假日数量
for (let date in holidays) {
  if (holidayCount >= 3) { // 只显示三个节假日
    break;
  }
  let holiday = holidays[date];
  if (holiday.holiday && !displayedHolidays.includes(holiday.name)) { // 避免重复显示
    let holidayDate = moment(holiday.date);
    let daysDiff = holidayDate.diff(moment(today), 'days');

    // 只显示假期大于1天的节假日
    if (holiday.rest > 1) {
      // 只显示距离节假日第一天的时间（第一天之后不显示）
      if (daysDiff >= 0) {
        result += `<span style="font-family: 楷体; font-size: 25px;">      距离 ${holiday.name}假期 还有 ${daysDiff}天 （${holiday.date}）</span><br>`;
        displayedHolidays.push(holiday.name); // 将已显示的节假日添加到数组中
        holidayCount++; // 增加计数器
      } 
    }
  }
}

dv.paragraph(`<span style="font-family: 优设鲨鱼菲特健康体; font-size: 50px; line-height: 75px;">${clockEmoji} 现在是 ${year}年${month}月${date}日 ${dayOfWeek[day]} ${timePeriod} ${String(formattedHour).padStart(2, '0')}:${String(minute).padStart(2, '0')} ${amPm}.</span><br>${result}`);
```
```dataviewjs
// 获取所有页面，筛选开始日期和完成日期都不为空的项目
const pages = dv.pages('"藏书阁/阅读"')
  .where(p => p.开始时间 != null && (p.结束时间 != null || p.结束时间 == ""));

// 检查是否存在符合条件的项目
if (pages.length === 0) {
  dv.paragraph("继续加油努力吧");
} else {
  // 存储没有评价和没有打分的游戏
  let noCommentGames = [];
  let noScoreGames = [];

  pages.forEach(p => {
    const encodedPath = encodeURI(p.file.path);
    const titleLink = `[${p["标题"]}](${encodedPath})`;

    // 检查评价
    if (!p["评价"]) {
      noCommentGames.push(titleLink);
    }

    // 检查打分（假设打分字段名为“评分”）
    if (!p["评分"]) {
      noScoreGames.push(titleLink);
    }
  });

  // 显示没有评价的提示和游戏
  if (noCommentGames.length > 0) {
    dv.paragraph("说点什么吧");
    dv.list(noCommentGames);
  }

  // 显示没有打分的提示和游戏
  if (noScoreGames.length > 2) {
    dv.paragraph("还没有打分哦");
    dv.list(noScoreGames);
  }
}
```

```dataview
table without ID  link(file.link, 标题) as 标题, "[" + 种类 + "](" + 链接 + ")" as 种类, 用时, 评分, 开始时间, 结束时间, done as "完成状态"
from "藏书阁/阅读"
sort 开始时间 asc
WHERE done = true
```


- 不用的组件


